<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Neon Hand Particles + Air Writing</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Noto Sans CJK SC",Arial}
    #wrap{position:fixed;inset:0}
    video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1);filter:contrast(1.05)saturate(1.08) brightness(0.95)}
    canvas{position:absolute;inset:0;width:100%;height:100%}
    .fx::before{
      content:"";position:absolute;inset:0;
      background:repeating-linear-gradient(to bottom,rgba(255,255,255,.035)0,rgba(255,255,255,.035)1px,rgba(0,0,0,0)3px,rgba(0,0,0,0)6px);
      mix-blend-mode:overlay;pointer-events:none;opacity:.35
    }
    .fx::after{
      content:"";position:absolute;inset:-20%;
      background:radial-gradient(ellipse at center,rgba(0,0,0,0)0%,rgba(0,0,0,.55)55%,rgba(0,0,0,.92)100%);
      pointer-events:none;opacity:.95
    }
    #hud{
      position:absolute;left:12px;top:12px;right:12px;z-index:20;
      display:flex;gap:10px;align-items:center;justify-content:space-between;
      color:rgba(190,235,255,.92);text-shadow:0 0 14px rgba(80,180,255,.65);
      pointer-events:none;font-size:12px;letter-spacing:.06em
    }
    #badge{display:flex;gap:10px;align-items:center;font-weight:800}
    #dot{width:8px;height:8px;border-radius:50%;background:#00e5ff;box-shadow:0 0 14px rgba(0,229,255,.95)}
    #panel{
      position:absolute;left:12px;bottom:12px;right:12px;z-index:20;
      display:flex;gap:10px;align-items:flex-end;justify-content:space-between;
      pointer-events:auto
    }
    #btn{
      appearance:none;border:1px solid rgba(120,200,255,.28);
      background:rgba(0,0,0,.35);color:rgba(220,250,255,.96);
      padding:12px 14px;border-radius:16px;font-size:14px;font-weight:800;
      backdrop-filter:blur(10px);
      box-shadow:0 0 18px rgba(0,229,255,.18)
    }
    #btn:active{transform:translateY(1px)}
    #status{
      max-width:70%;
      color:rgba(220,250,255,.9);
      font-size:12px;line-height:1.35;
      white-space:pre-wrap;
      text-shadow:0 0 12px rgba(80,180,255,.45);
      background:rgba(0,0,0,.38);
      border:1px solid rgba(120,200,255,.18);
      border-radius:14px;padding:10px 12px;
      backdrop-filter:blur(10px)
    }
    #fs{
      appearance:none;border:1px solid rgba(120,200,255,.18);
      background:rgba(0,0,0,.22);color:rgba(210,245,255,.92);
      padding:10px 12px;border-radius:14px;font-size:12px;font-weight:800;
      backdrop-filter:blur(10px);
    }
    #fs:active{transform:translateY(1px)}
  </style>
</head>

<body>
<div id="wrap" class="fx">
  <video id="video" playsinline muted></video>

  <!-- three.js 渲染层 -->
  <canvas id="three"></canvas>
  <!-- 写字层（会保留） -->
  <canvas id="draw"></canvas>
  <!-- 雪花消散层 -->
  <canvas id="snow"></canvas>
  <!-- 手势 UI 面板层（用食指指针选择） -->
  <canvas id="ui"></canvas>

  <div id="hud">
    <div id="badge"><span id="dot"></span><span>NEON HAND SYSTEM</span></div>
    <div id="hint">手掌=打开/关闭面板｜捏合=写字/点击｜双手食指=缩放字｜“V(食指+中指)”=雪花消散</div>
  </div>

  <div id="panel">
    <div style="display:flex;gap:8px;align-items:center">
      <button id="btn">启动</button>
      <button id="fs">全屏</button>
    </div>
    <div id="status">未启动</div>
  </div>
</div>

<script>
  // ========= 0) 基础工具 =========
  const $ = (id)=>document.getElementById(id);
  const video = $("video");
  const cThree = $("three"), cDraw = $("draw"), cSnow = $("snow"), cUI = $("ui");
  const statusEl = $("status");
  const btn = $("btn");
  const fsBtn = $("fs");

  function setStatus(s){ statusEl.textContent = s; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  function resizeCanvas(canvas){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return ctx;
  }
  const ctxDraw = resizeCanvas(cDraw);
  const ctxSnow = resizeCanvas(cSnow);
  const ctxUI = resizeCanvas(cUI);
  addEventListener("resize", ()=>{
    resizeCanvas(cThree); // three 会自己 setSize
    resizeCanvas(cDraw);
    resizeCanvas(cSnow);
    resizeCanvas(cUI);
    if (three) three.onResize();
  });

  // ========= 1) 动态加载：Three.js + MediaPipe =========
  async function tryImport(url){
    try { return await import(url); } catch(e){ return null; }
  }
  async function loadThree(){
    const candidates = [
      "https://fastly.jsdelivr.net/npm/three@0.172.0/build/three.module.js",
      "https://gcore.jsdelivr.net/npm/three@0.172.0/build/three.module.js",
      "https://cdn.jsdelivr.net/npm/three@0.172.0/build/three.module.js",
      "https://unpkg.com/three@0.172.0/build/three.module.js",
    ];
    for(const u of candidates){
      setStatus("加载 Three.js…\n" + u);
      const m = await tryImport(u);
      if(m) return m;
    }
    throw new Error("Three.js 加载失败（CDN 都不可用）");
  }

  function loadScript(url){
    return new Promise((resolve,reject)=>{
      const s = document.createElement("script");
      s.src = url;
      s.crossOrigin = "anonymous";
      s.onload = resolve;
      s.onerror = ()=>reject(new Error("脚本加载失败: " + url));
      document.head.appendChild(s);
    });
  }

  async function loadMediaPipeBundle(){
    // 官方文档给出的 CDN 方式就是 vision_bundle.js（我们做多源容灾）1
    const candidates = [
      "https://fastly.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js",
      "https://gcore.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js",
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js",
      "https://unpkg.com/@mediapipe/tasks-vision/vision_bundle.js",
    ];
    let lastErr = null;
    for(const u of candidates){
      try{
        setStatus("加载 MediaPipe 引擎…\n" + u);
        await loadScript(u);
        if (window.FilesetResolver && window.HandLandmarker) return;
      }catch(e){ lastErr = e; }
    }
    throw lastErr || new Error("MediaPipe 脚本加载失败（所有源都失败）");
  }

  async function fetchOk(url, ms=7000){
    const controller = new AbortController();
    const t = setTimeout(()=>controller.abort(), ms);
    try{
      const r = await fetch(url, {method:"GET", cache:"no-store", signal: controller.signal});
      clearTimeout(t);
      return r.ok;
    }catch(e){
      clearTimeout(t);
      return false;
    }
  }

  // ========= 2) Three 粒子系统（可换模型 + 颜色） =========
  let THREE = null;
  let three = null;

  function makeShapePoints(shape, count){
    // 返回 Float32Array count*3，范围大致在 [-1,1]
    const out = new Float32Array(count*3);
    const rand = ()=>Math.random();

    function heart(t){
      // 经典心形参数方程（2D），我们加一点 z 抖动
      const x = 16*Math.pow(Math.sin(t),3);
      const y = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
      return [x/18, y/18];
    }

    function rose(t, k=5){
      // 花朵：玫瑰线 r = sin(kθ)
      const r = Math.sin(k*t);
      return [r*Math.cos(t), r*Math.sin(t)];
    }

    function spherePoint(){
      const u = rand(), v = rand();
      const theta = 2*Math.PI*u;
      const phi = Math.acos(2*v-1);
      const x = Math.sin(phi)*Math.cos(theta);
      const y = Math.cos(phi);
      const z = Math.sin(phi)*Math.sin(theta);
      return [x,y,z];
    }

    for(let i=0;i<count;i++){
      const i3=i*3;
      if(shape==="heart"){
        const t = rand()*Math.PI*2;
        const [x,y]=heart(t);
        out[i3]=x;
        out[i3+1]=y;
        out[i3+2]=(rand()*2-1)*0.10;
      } else if(shape==="flower"){
        const t = rand()*Math.PI*2;
        const [x,y]=rose(t, 6);
        out[i3]=x*1.05;
        out[i3+1]=y*1.05;
        out[i3+2]=(rand()*2-1)*0.12;
      } else if(shape==="saturn"){
        // 土星：球体 + 环
        if(rand()<0.55){
          const [x,y,z]=spherePoint();
          out[i3]=x*0.55;
          out[i3+1]=y*0.55;
          out[i3+2]=z*0.55;
        } else {
          const t = rand()*Math.PI*2;
          const r = 0.85 + (rand()*2-1)*0.05;
          out[i3]=Math.cos(t)*r;
          out[i3+1]=(rand()*2-1)*0.06;
          out[i3+2]=Math.sin(t)*r;
        }
      } else if(shape==="buddha"){
        // “佛像”抽象：头+身体+莲座+光环（非常简化，偏赛博雕塑）
        const pick = rand();
        if(pick < 0.30){
          // 头
          const [x,y,z]=spherePoint();
          out[i3]=x*0.25;
          out[i3+1]=y*0.25 + 0.55;
          out[i3+2]=z*0.25;
        } else if(pick < 0.80){
          // 身体
          const [x,y,z]=spherePoint();
          out[i3]=x*0.38;
          out[i3+1]=y*0.50 + 0.10;
          out[i3+2]=z*0.30;
        } else {
          // 光环
          const t = rand()*Math.PI*2;
          const r = 0.55 + (rand()*2-1)*0.02;
          out[i3]=Math.cos(t)*r;
          out[i3+1]=0.70 + (rand()*2-1)*0.03;
          out[i3+2]=Math.sin(t)*r;
        }
      } else if(shape==="fireworks"){
        // 烟花：先给一个“球壳”点，后续动画会爆散
        const [x,y,z]=spherePoint();
        out[i3]=x*0.25;
        out[i3+1]=y*0.25;
        out[i3+2]=z*0.25;
      } else {
        // 默认随机云
        out[i3]=(rand()*2-1);
        out[i3+1]=(rand()*2-1);
        out[i3+2]=(rand()*2-1)*0.6;
      }
    }
    return out;
  }

  function createThreeParticleSystem(){
    const renderer = new THREE.WebGLRenderer({ canvas: cThree, antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(2, devicePixelRatio || 1));
    renderer.setSize(innerWidth, innerHeight);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.01, 50);
    camera.position.set(0,0,3.2);

    // 粒子数量（手机适配）
    const low = (navigator.hardwareConcurrency || 4) <= 4;
    const COUNT = low ? 14000 : 24000;

    let shape = "heart";
    let base = makeShapePoints(shape, COUNT);

    const pos = new Float32Array(COUNT*3);
    pos.set(base);

    const phase = new Float32Array(COUNT);
    for(let i=0;i<COUNT;i++) phase[i] = Math.random()*Math.PI*2;

    const geo = new THREE.BufferGeometry();
    geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    geo.setAttribute("aPhase", new THREE.BufferAttribute(phase, 1));

    const uniforms = {
      uTime: { value: 0 },
      uColor: { value: new THREE.Color("#00e5ff") },
      uSize: { value: 2.4 },
      uGlow: { value: 1.0 },
    };

    const mat = new THREE.ShaderMaterial({
      transparent:true,
      depthWrite:false,
      blending: THREE.AdditiveBlending,
      uniforms,
      vertexShader: `
        uniform float uTime;
        uniform float uSize;
        attribute float aPhase;
        varying float vA;
        void main(){
          vec3 p = position;
          // 轻微呼吸波动（未来感）
          float wob = sin(uTime*1.2 + aPhase)*0.015 + sin(uTime*0.7 + aPhase*1.7)*0.010;
          p.xy += wob;
          vec4 mv = modelViewMatrix * vec4(p,1.0);
          gl_Position = projectionMatrix * mv;
          gl_PointSize = uSize * (340.0 / -mv.z);
          vA = 0.65 + 0.35*sin(uTime*2.0 + aPhase);
        }
      `,
      fragmentShader: `
        precision highp float;
        uniform vec3 uColor;
        uniform float uGlow;
        varying float vA;
        void main(){
          vec2 uv = gl_PointCoord.xy - 0.5;
          float r = length(uv);
          if(r>0.5) discard;
          float core = smoothstep(0.38, 0.0, r);
          float ring = smoothstep(0.50, 0.35, r) * 0.55;
          float a = (core + ring) * vA * uGlow;
          vec3 col = uColor;
          col.b += (1.0 - smoothstep(0.0, 0.5, r))*0.25;
          gl_FragColor = vec4(col, a);
        }
      `
    });

    const points = new THREE.Points(geo, mat);
    scene.add(points);

    // fireworks 模式需要速度
    let fwVel = null;

    const api = {
      shape,
      color: "#00e5ff",
      setColor(hex){
        api.color = hex;
        uniforms.uColor.value.set(hex);
      },
      setShape(newShape){
        api.shape = newShape;
        shape = newShape;
        base = makeShapePoints(shape, COUNT);
        if(shape==="fireworks"){
          fwVel = new Float32Array(COUNT*3);
          for(let i=0;i<COUNT;i++){
            const i3=i*3;
            // 初始速度向外
            const x=base[i3], y=base[i3+1], z=base[i3+2];
            const len = Math.sqrt(x*x+y*y+z*z) + 1e-6;
            fwVel[i3] = x/len*(0.010 + Math.random()*0.012);
            fwVel[i3+1] = y/len*(0.010 + Math.random()*0.012);
            fwVel[i3+2] = z/len*(0.010 + Math.random()*0.012);
          }
        } else {
          fwVel = null;
        }
        // 立刻刷新位置
        pos.set(base);
        geo.attributes.position.needsUpdate = true;
      },
      // 手势控制参数（双手张合）
      control: {
        targetScale: 1.0,
        targetDisp: 0.15,
      },
      onResize(){
        renderer.setSize(innerWidth, innerHeight);
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
      },
      update(t){
        uniforms.uTime.value = t;
        // 基于手势的 scale/disp
        const s = api.control.targetScale;
        const d = api.control.targetDisp;

        // 更新点位：base * s + noise * d + swirl
        const time = t;
        for(let i=0;i<COUNT;i++){
          const i3=i*3;
          const ph = phase[i];
          const bx = base[i3], by = base[i3+1], bz = base[i3+2];

          if(shape==="fireworks"){
            // 烟花：爆散+重力+慢慢收拢再爆（循环）
            const vx = fwVel[i3], vy = fwVel[i3+1], vz = fwVel[i3+2];
            pos[i3]   = bx + vx * (1.0 + Math.sin(time*0.6)*0.2);
            pos[i3+1] = by + vy * (1.0 + Math.sin(time*0.6)*0.2) - (0.20*Math.max(0, Math.sin(time*0.5)));
            pos[i3+2] = bz + vz * (1.0 + Math.sin(time*0.6)*0.2);
            // 周期回收
            const k = 0.0025;
            base[i3]   = lerp(base[i3],   makeShapePoints("fireworks",1)[0], k);
            base[i3+1] = lerp(base[i3+1], makeShapePoints("fireworks",1)[1], k);
            base[i3+2] = lerp(base[i3+2], makeShapePoints("fireworks",1)[2], k);
          } else {
            const nx = Math.sin(time*0.9 + ph) * d * 0.30;
            const ny = Math.cos(time*1.1 + ph*1.3) * d * 0.30;
            const nz = Math.sin(time*1.4 + ph*0.7) * d * 0.18;

            // 漩涡
            const sw = (0.35 + d*0.9) * 0.12;
            const sx = -by * sw;
            const sy =  bx * sw;

            pos[i3]   = (bx*s) + nx + sx;
            pos[i3+1] = (by*s) + ny + sy;
            pos[i3+2] = (bz*s) + nz;
          }
        }
        geo.attributes.position.needsUpdate = true;

        // 粒子大小随扩散变化
        uniforms.uSize.value = 2.0 + d*3.0;
        uniforms.uGlow.value = 0.85 + d*0.85;

        renderer.render(scene, camera);
      }
    };

    return api;
  }

  // ========= 3) 写字系统（画布保留 + 橡皮擦 + 颜色/大小 + 双手缩放） =========
  const drawState = {
    tool: "pen",      // pen | eraser
    color: "#b9f5ff",
    size: 10,
    // 画布变换（用于双手食指缩放文字）
    scale: 1.0,
    offX: 0,
    offY: 0,
    // 书写状态
    writing: false,
    lastX: null,
    lastY: null,
    // 缓存画布（用于缩放重绘）
    buffer: document.createElement("canvas"),
    bufferCtx: null,
  };
  drawState.buffer.width = cDraw.width;
  drawState.buffer.height = cDraw.height;
  drawState.bufferCtx = drawState.buffer.getContext("2d");

  function screenToDraw(x,y){
    // 将屏幕坐标映射到绘制坐标（考虑缩放+平移）
    const dx = (x - drawState.offX) / drawState.scale;
    const dy = (y - drawState.offY) / drawState.scale;
    return {x: dx, y: dy};
  }

  function redrawFromBuffer(){
    // 将 buffer 以当前变换重绘到 drawCanvas
    ctxDraw.clearRect(0,0,innerWidth,innerHeight);
    ctxDraw.save();
    ctxDraw.translate(drawState.offX, drawState.offY);
    ctxDraw.scale(drawState.scale, drawState.scale);
    ctxDraw.drawImage(drawState.buffer, 0, 0, innerWidth, innerHeight);
    ctxDraw.restore();
  }

  function commitStrokeToBuffer(){
    // 把当前 drawCanvas 画面写回 buffer（避免多次缩放损失）
    const dpr = Math.min(2, devicePixelRatio || 1);
    drawState.bufferCtx.setTransform(dpr,0,0,dpr,0,0);
    drawState.bufferCtx.clearRect(0,0,innerWidth,innerHeight);
    drawState.bufferCtx.drawImage(cDraw, 0, 0);
  }

  // ========= 4) 雪花消散（从文字采样成小雪花，飘落并消失） =========
  const snow = [];
  function triggerSnowDissolve(){
    const dpr = Math.min(2, devicePixelRatio || 1);
    // 取 drawCanvas 像素
    const img = ctxDraw.getImageData(0,0,Math.floor(innerWidth*dpr),Math.floor(innerHeight*dpr));
    const data = img.data;
    snow.length = 0;

    const step = 8; // 采样间隔（越小越密，越耗性能）
    for(let y=0;y<img.height;y+=step){
      for(let x=0;x<img.width;x+=step){
        const i = (y*img.width + x)*4;
        const a = data[i+3];
        if(a > 40){
          const r=data[i], g=data[i+1], b=data[i+2];
          snow.push({
            x: x/dpr,
            y: y/dpr,
            vx: (Math.random()*2-1)*0.6,
            vy: 0.8 + Math.random()*1.8,
            rot: Math.random()*Math.PI*2,
            vr: (Math.random()*2-1)*0.08,
            a: a/255,
            col: `rgba(${r},${g},${b},`,
            life: 1.0
          });
        }
      }
    }

    // 清空文字层 & buffer
    ctxDraw.clearRect(0,0,innerWidth,innerHeight);
    drawState.bufferCtx.clearRect(0,0,innerWidth,innerHeight);
    drawState.lastX = drawState.lastY = null;
    drawState.writing = false;
  }

  function updateSnow(){
    ctxSnow.clearRect(0,0,innerWidth,innerHeight);
    if(snow.length===0) return;

    ctxSnow.globalCompositeOperation = "lighter";
    for(let i=snow.length-1;i>=0;i--){
      const p = snow[i];
      p.rot += p.vr;
      p.vx += Math.sin(p.rot)*0.01;
      p.vy += 0.015; // gravity
      p.x += p.vx;
      p.y += p.vy;
      p.life *= 0.985;
      p.a *= 0.985;

      const alpha = p.a * p.life;
      if(alpha < 0.03 || p.y > innerHeight+30){
        snow.splice(i,1);
        continue;
      }

      ctxSnow.save();
      ctxSnow.translate(p.x,p.y);
      ctxSnow.rotate(p.rot);
      ctxSnow.fillStyle = p.col + alpha + ")";
      ctxSnow.fillRect(-1.0,-1.0,2.0,2.0);
      ctxSnow.restore();
    }
    ctxSnow.globalCompositeOperation = "source-over";
  }

  // ========= 5) 手势识别：HandLandmarker（双手） =========
  let landmarker = null;
  let running = false;
  let lastVideoTime = -1;

  // UI/交互状态
  const uiState = {
    menuOpen: false,
    menuHold: 0,
    lastMenuToggle: 0,
    pointerX: innerWidth*0.5,
    pointerY: innerHeight*0.5,
    pinch: false,
    pinchEdge: false,
    lastPinch: false,

    // 双手缩放文字
    scaleMode: false,
    scaleStartDist: 0,
    scaleStartScale: 1.0,
    scaleStartOffX: 0,
    scaleStartOffY: 0,
    scaleMidX: 0,
    scaleMidY: 0,

    // 粒子控制：双手张合
    openAvg: 0.35,   // 0捏合 1张开
  };

  function toScreen(pt){
    // pt.x/pt.y 为 0..1，视频镜像，因此 x 需要 (1-x)
    return {
      x: (1-pt.x) * innerWidth,
      y: pt.y * innerHeight
    };
  }

  function dist01(a,b){
    const dx = a.x-b.x, dy=a.y-b.y;
    return Math.sqrt(dx*dx+dy*dy);
  }

  function fingerExtended(lm, tip, pip, mcp){
    // y 越小越靠上：tip < pip < mcp 代表伸直（大多数情况下可用）
    return (lm[tip].y < lm[pip].y) && (lm[pip].y < lm[mcp].y);
  }

  function isOpenPalm(lm){
    const idx = fingerExtended(lm, 8, 6, 5);
    const mid = fingerExtended(lm,12,10, 9);
    const rng = fingerExtended(lm,16,14,13);
    const pky = fingerExtended(lm,20,18,17);
    // 4 个手指伸直基本可认为“手掌展开”
    return idx && mid && rng && pky;
  }

  function isVDissolve(lm){
    const idx = fingerExtended(lm, 8, 6, 5);
    const mid = fingerExtended(lm,12,10, 9);
    const rng = fingerExtended(lm,16,14,13);
    const pky = fingerExtended(lm,20,18,17);
    // V：食指+中指伸直，环指/小指收起
    return idx && mid && (!rng) && (!pky);
  }

  function pinch01(lm){
    // 拇指尖 4 与 食指尖 8 的距离（归一化）
    const d = dist01(lm[4], lm[8]);
    // 经验阈值（小=捏合）
    // 映射成 0..1（0=捏合，1=张开）
    return clamp(d / 0.25, 0, 1);
  }

  // ========= 6) UI 面板（用食指指针 hover，捏合=点击） =========
  
